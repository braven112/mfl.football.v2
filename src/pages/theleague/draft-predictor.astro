---
/**
 * Draft Predictor Page
 * Displays projected draft order for next season based on current standings
 * Updates as season progresses with real-time standings
 */

import TheLeagueLayout from '../../layouts/TheLeagueLayout.astro';
import DraftPredictorGrid from '../../components/theleague/DraftPredictorGrid.astro';
import DraftViewSelector from '../../components/theleague/DraftViewSelector.astro';
import leagueAssets from '../../data/theleague.assets.json';
import { calculateDraftOrder, buildActualDraftPicks, convertActualPicksToPredictions, parseTradeFromComment } from '../../utils/draft-utils';
import { extractToiletBowlWinners } from '../../utils/toilet-bowl-utils';
import { convertAssetsToPredictions, isValidAssetsData, extractAssetsFromTransactions } from '../../utils/assets-utils';
import { getPlayerImageUrl, getNflLogoUrl, DEFAULT_HEADSHOT_URL } from '../../constants/roster-constants';
import type { DraftPrediction } from '../../types/standings';
import { getTheLeaguePreference, setTheLeaguePreference, resolveTeamSelection } from '../../utils/team-preferences';
import { getAuthUser } from '../../utils/auth';

const standingsFeeds = import.meta.glob('../../../data/theleague/mfl-feeds/*/standings.json', {
  eager: true,
});
const playoffBracketFeeds = import.meta.glob(
  '../../../data/theleague/mfl-feeds/*/playoff-brackets.json',
  {
    eager: true,
  }
);
const draftResultsFeeds = import.meta.glob('../../../data/theleague/mfl-feeds/*/draftResults.json', {
  eager: true,
});
const playersFeeds = import.meta.glob('../../../data/theleague/mfl-feeds/*/players.json', {
  eager: true,
});
const assetsFeeds = import.meta.glob('../../../data/theleague/mfl-feeds/*/assets.json', {
  eager: true,
});
const transactionsFeeds = import.meta.glob('../../../data/theleague/mfl-feeds/*/transactions.json', {
  eager: true,
});

const getModuleData = (mod: any) =>
  mod && typeof mod === 'object' && 'default' in mod ? mod.default : mod;

const extractFeedSeason = (filepath: string) => {
  const match = filepath.match(/mfl-feeds\/(\d{4})\//);
  return match ? match[1] : null;
};

// Get current year from environment variable (fallback to current year for safety)
const currentYear = parseInt(import.meta.env.PUBLIC_MFL_YEAR || new Date().getFullYear().toString(), 10);
const nextYear = currentYear + 1;

// Load standings for current year
const standingsKey = Object.keys(standingsFeeds).find(
  (path) => extractFeedSeason(path) === String(currentYear)
);
const standingsData = standingsKey ? getModuleData(standingsFeeds[standingsKey]) : null;

// Load playoff bracket for current year to determine toilet bowl winners
const bracketKey = Object.keys(playoffBracketFeeds).find(
  (path) => extractFeedSeason(path) === String(currentYear)
);
const bracketData = bracketKey ? getModuleData(playoffBracketFeeds[bracketKey]) : null;

// Load draft results for next year (to show actual picks with trades)
const draftResultsKey = Object.keys(draftResultsFeeds).find(
  (path) => extractFeedSeason(path) === String(nextYear)
);
const draftResultsData = draftResultsKey ? getModuleData(draftResultsFeeds[draftResultsKey]) : null;

// All available years for history view
const draftResultYears = Object.keys(draftResultsFeeds)
  .map((path) => extractFeedSeason(path))
  .filter((y) => !!y)
  .sort((a, b) => Number(b) - Number(a));

// Load assets for current year (to show team ownership of draft picks)
let assetsData = null;
const assetsKey = Object.keys(assetsFeeds).find(
  (path) => extractFeedSeason(path) === String(currentYear)
);
if (assetsKey) {
  assetsData = getModuleData(assetsFeeds[assetsKey]);
}

// Fallback: extract assets from transactions if API data is unavailable
if (!assetsData || !isValidAssetsData(assetsData)) {
  const transactionsKey = Object.keys(transactionsFeeds).find(
    (path) => extractFeedSeason(path) === String(currentYear)
  );
  const transactionsData = transactionsKey ? getModuleData(transactionsFeeds[transactionsKey]) : null;

  if (transactionsData && standingsData) {
    assetsData = extractAssetsFromTransactions(transactionsData, standingsData, nextYear);
  }
}

// Build team config map
const teamsList = (leagueAssets.teams ?? []).map((team) => ({
  id: team.id,
  name: team.name,
  icon: team.assets?.icons?.[0]?.relativePath ?? '',
  banner: team.assets?.banners?.[0]?.relativePath ?? '',
}));

const teamConfigMap = new Map(teamsList.map((team) => [team.id, team]));

// Extract toilet bowl winners
let toiletBowlWinners = [];
if (bracketData) {
  toiletBowlWinners = extractToiletBowlWinners(bracketData);
}

// Calculate draft predictions
let draftPredictions = [];
let leagueWinnerId = '';
let specialPickMap = new Map<string, DraftPrediction>();

if (standingsData?.leagueStandings?.franchise) {
  // TODO: Determine league winner (champion playoff winner)
  // For now, assume first team in standings, but this needs real logic
  const franchises = standingsData.leagueStandings.franchise;

  // Draft predictions will be calculated once we have toilet bowl winners
  draftPredictions = calculateDraftOrder(
    franchises,
    teamConfigMap,
    leagueWinnerId,
    toiletBowlWinners
  );

  // Track special (compensatory) picks from bracket winners so we can override downstream
  specialPickMap = new Map(
    draftPredictions
      .filter(p => p.isToiletBowlPick)
      .map(p => [`${p.round}.${p.pickInRound}`, p])
  );
}

// Sort by overall pick number
const sortedPredictions = draftPredictions.sort(
  (a, b) => a.overallPickNumber - b.overallPickNumber
);

// Build actual draft picks from draft results (showing current ownership after trades)
let actualDraftPicksRaw: ReturnType<typeof buildActualDraftPicks> = [];
let actualDraftPicks: ReturnType<typeof convertActualPicksToPredictions> = [];
if (draftResultsData) {
  actualDraftPicksRaw = buildActualDraftPicks(draftResultsData, teamConfigMap);
  actualDraftPicks = convertActualPicksToPredictions(actualDraftPicksRaw, teamConfigMap);
}

// Get view from query parameter (default to 'final'); map deprecated 'assets' to 'final'
const rawView = Astro.url.searchParams.get('view') || 'final';
const normalizedView = rawView === 'assets' ? 'final' : rawView === 'trades' ? 'history' : rawView;
const view = normalizedView as 'projected' | 'final' | 'history';

// Final order favors traded/actual ownership, then falls back to projection
const finalBase =
  (assetsData && isValidAssetsData(assetsData) && convertAssetsToPredictions(assetsData, teamConfigMap).length > 0)
    ? convertAssetsToPredictions(assetsData, teamConfigMap)
    : actualDraftPicks.length > 0
      ? actualDraftPicks
      : sortedPredictions;
const mergeSpecialPicks = (
  base: DraftPrediction[],
  specials: Map<string, DraftPrediction>
) => {
  const merged = new Map<string, DraftPrediction>();
  base.forEach(p => merged.set(`${p.round}.${p.pickInRound}`, p));
  specials.forEach((p, key) => merged.set(key, p));
  return Array.from(merged.values()).sort((a, b) => a.overallPickNumber - b.overallPickNumber);
};

const finalPredictions = mergeSpecialPicks(finalBase, specialPickMap);

// History view: pick a year and show all draft picks with trade notes
const historyYearParam = Astro.url.searchParams.get('year');
const historyYear =
  (historyYearParam && draftResultYears.includes(historyYearParam) && historyYearParam) ||
  draftResultYears[0] ||
  String(currentYear);

const historyResultsKey = Object.keys(draftResultsFeeds).find(
  (path) => extractFeedSeason(path) === String(historyYear)
);
const historyResultsData = historyResultsKey ? getModuleData(draftResultsFeeds[historyResultsKey]) : null;

const playerFeedYears = Object.keys(playersFeeds)
  .map((path) => extractFeedSeason(path))
  .filter((y) => !!y)
  .map((y) => Number(y))
  .sort((a, b) => b - a);

const resolvePlayersDataForYear = (year: number | string) => {
  const numeric = Number(year);
  const exactKey = Object.keys(playersFeeds).find(
    (path) => extractFeedSeason(path) === String(year)
  );
  if (exactKey) return getModuleData(playersFeeds[exactKey]);

  const fallbackYear = playerFeedYears.find((y) => y <= numeric) ?? playerFeedYears[0];
  const fallbackKey = Object.keys(playersFeeds).find(
    (path) => extractFeedSeason(path) === String(fallbackYear)
  );
  return fallbackKey ? getModuleData(playersFeeds[fallbackKey]) : null;
};

const historyPlayersData = resolvePlayersDataForYear(historyYear);

const buildPlayerLookup = (playersData: any) => {
  const lookup = new Map<
    string,
    { name: string; position?: string; nflTeam?: string; espnId?: string }
  >();
  const players = playersData?.players?.player;
  const list = Array.isArray(players) ? players : players ? [players] : [];
  list.forEach((p: any) => {
    if (!p?.id) return;
    lookup.set(p.id, {
      name: p.name || '',
      position: p.position || '',
      nflTeam: p.team || p.draft_team || '',
      espnId: p.espn_id || '',
    });
  });
  return lookup;
};

const buildHeadshotUrl = (playerId: string, espnId?: string) => {
  if (espnId) {
    return `https://a.espncdn.com/i/headshots/nfl/players/full/${espnId}.png`;
  }
  return getPlayerImageUrl(playerId);
};

const normalizeNflTeamCode = (code = '') => {
  const upper = code.toUpperCase();
  const map: Record<string, string> = {
    GBP: 'GB',
    GNB: 'GB',
    NEP: 'NE',
    NWE: 'NE',
    NOS: 'NO',
    NOR: 'NO',
    TBB: 'TB',
    TAM: 'TB',
    KCC: 'KC',
    JAX: 'JAX',
    JAC: 'JAX',
    LVR: 'LV',
    OAK: 'LV',
    SFO: 'SF',
    SFR: 'SF',
    WAS: 'WAS',
    WFT: 'WAS',
    STL: 'LAR',
    SD: 'LAC',
    SDG: 'LAC',
    HST: 'HOU',
  };
  return map[upper] || upper;
};

const historyPlayerLookup = buildPlayerLookup(historyPlayersData);

// Team personalization: URL params + cookie integration
const myTeamParam = Astro.url.searchParams.get('myteam');
const franchiseParam = Astro.url.searchParams.get('franchise');
const cookiePreference = getTheLeaguePreference(Astro.cookies);
const authUser = getAuthUser(Astro.request);

// If myteam param is provided, update the cookie
if (myTeamParam) {
  setTheLeaguePreference(Astro.cookies, myTeamParam);
}

// Resolve which team to highlight/filter by (priority: myteam → franchise → cookie → auth → null)
const selectedTeamId = resolveTeamSelection({
  myTeamParam,
  franchiseParam,
  cookiePreference: cookiePreference?.franchiseId,
  authUserFranchise: authUser?.franchiseId,
  defaultTeam: '', // No default for draft predictor - user might not have picks
});

const buildHistoryRows = (
  resultsData: any,
  teamConfigs: Map<string, { id: string; name: string; icon: string; banner: string }>,
  playerLookup: Map<string, { name: string; position?: string; nflTeam?: string }>
) => {
  const picks = resultsData?.draftResults?.draftUnit?.draftPick;
  if (!picks) return [];
  const pickArray = Array.isArray(picks) ? picks : [picks];

  return pickArray
    .filter((p: any) => p.round && p.pick && p.franchise)
    .map((p: any) => {
      const roundNum = parseInt(p.round, 10);
      const pickNum = parseInt(p.pick, 10);
      const overallPickNumber = (roundNum - 1) * 16 + pickNum;
      const teamName = teamConfigs.get(p.franchise)?.name || 'Unknown Team';
      const teamBanner = teamConfigs.get(p.franchise)?.banner || '';
      const originalTeam = parseTradeFromComment(p.comments || '');
      const playerInfo = playerLookup.get(p.player) || {};
      const playerName = playerInfo.name || p.player || '';
      const position = playerInfo.position || '';
      const nflTeam = normalizeNflTeamCode(playerInfo.nflTeam || '');
      const headshot = buildHeadshotUrl(p.player, playerInfo.espnId);
      const nflLogo = getNflLogoUrl(nflTeam);
      return {
        overallPickNumber,
        round: roundNum,
        pick: pickNum,
        franchiseId: p.franchise,
        teamName,
        teamBanner,
        originalTeam,
        playerId: p.player || '',
        playerName,
        position,
        nflTeam,
        headshot,
        nflLogo,
        player: p.player || '',
        notes: p.comments || '',
      };
    })
    .sort((a, b) => a.overallPickNumber - b.overallPickNumber);
};

const historyRows = buildHistoryRows(historyResultsData, teamConfigMap, historyPlayerLookup);
const historyTeamParam = Astro.url.searchParams.get('team');

// Default history team filter to user's preferred team (if they have one)
const defaultHistoryTeam = selectedTeamId && teamConfigMap.has(selectedTeamId) ? selectedTeamId : 'all';
const historyTeam =
  historyTeamParam && historyTeamParam !== 'all' && teamConfigMap.has(historyTeamParam)
    ? historyTeamParam
    : defaultHistoryTeam;

const filteredHistoryRows = historyRows.filter((row) =>
  historyTeam === 'all' ? true : row.franchiseId === historyTeam
);
---

<TheLeagueLayout title="Draft Predictor">
  <section class="draft-predictor-page">
    <header class="draft-predictor-header">
      <div>
        <h1 class="draft-predictor-title">{nextYear} Draft Order</h1>
        <p class="draft-predictor-subtitle">
          {view === 'projected' && `Projected base draft order based on current ${currentYear} season standings`}
          {view === 'final' && `Projected final draft order with traded pick ownership applied`}
          {view === 'history' && `Draft history and pick trades by year`}
        </p>
      </div>
      <DraftViewSelector activeView={view} />
    </header>

    <div class="draft-predictor-content">
      {sortedPredictions.length > 0 ? (
        <>
          {view === 'projected' && (
            <DraftPredictorGrid predictions={sortedPredictions} userTeamId={selectedTeamId} />
          )}
          {view === 'final' && finalPredictions.length > 0 && (
            <DraftPredictorGrid predictions={finalPredictions} userTeamId={selectedTeamId} />
          )}
          {view === 'final' && finalPredictions.length === 0 && (
            <div class="draft-predictor-loading">
              <p>No final draft order available yet.</p>
            </div>
          )}
          {view === 'history' && (
            <div class="draft-history">
              <div class="history-controls">
                <label for="historyYear">Season:</label>
                <select id="historyYear">
                  {draftResultYears.map((yr) => (
                    <option value={yr} selected={yr === historyYear}>{yr}</option>
                  ))}
                </select>
                <label for="historyTeam">Team:</label>
                <select id="historyTeam">
                  <option value="all" selected={historyTeam === 'all'}>All Teams</option>
                  {teamsList.map((team) => (
                    <option value={team.id} selected={team.id === historyTeam}>{team.name}</option>
                  ))}
                </select>
              </div>

              {filteredHistoryRows.length > 0 ? (
                <div class="history-table-wrapper">
                  <table class="history-table">
                    <thead>
                      <tr>
                        <th>Pick</th>
                        <th>Rd.</th>
                        <th>Team</th>
                        <th>Original Team</th>
                        <th>Player</th>
                        <th>Notes</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredHistoryRows.map((row) => (
                        <tr>
                          <td>{row.overallPickNumber}</td>
                          <td>{row.round}.{String(row.pick).padStart(2, '0')}</td>
                          <td>
                            {row.teamBanner ? (
                              <img src={row.teamBanner} alt={row.teamName} class="history-team-banner" />
                            ) : (
                              row.teamName
                            )}
                          </td>
                          <td>{row.originalTeam ?? '—'}</td>
                          <td>
                            {row.playerId ? (
                              <div class="history-player">
                                <img
                                  src={row.headshot}
                                  alt={row.playerName}
                                  class="history-player__headshot"
                                  onerror={`this.onerror=null;this.src='${DEFAULT_HEADSHOT_URL}';`}
                                />
                                <div class="history-player__meta">
                                  <div class="history-player__name">{row.playerName || '—'}</div>
                                  <div class="history-player__sub">
                                    {row.nflLogo && (
                                      <img
                                        src={row.nflLogo}
                                        alt={row.nflTeam}
                                        class="history-player__logo"
                                        onerror="this.onerror=null;this.src='/assets/nfl-logos/NFL.svg';"
                                      />
                                    )}
                                    <span class="history-player__pos">{row.position || '—'}</span>
                                  </div>
                                </div>
                              </div>
                            ) : (
                              row.player || '—'
                            )}
                          </td>
                          <td class="history-notes">{row.notes || '—'}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <div class="draft-predictor-loading">
                  <p>No draft results available yet for {historyYear}</p>
                </div>
              )}
            </div>
          )}
        </>
      ) : (
        <div class="draft-predictor-loading">
          <p>Loading draft predictions...</p>
        </div>
      )}
    </div>

    <div class="draft-predictor-info">
      <div class="info-card">
        <h3>How It Works</h3>
        <ul>
          <li>
            <strong>Regular Picks (1-15, 17-48):</strong> Determined by reverse standings order (worst record gets 1st pick)
          </li>
          <li>
            <strong>Pick 16:</strong> League champion always receives the 16th pick
          </li>
          <li>
            <strong>Compensatory Picks (1.17, 2.17, 2.18):</strong> Awarded to toilet bowl tournament winners
          </li>
          <li>
            <strong>Tiebreakers:</strong> Uses same wild card tiebreaker rules as standings (all-play %, points for, power rating, victory points, points against)
          </li>
          <li>
            <strong>Updates:</strong> Refreshes in real-time as season progresses
          </li>
        </ul>
      </div>
    </div>
  </section>
</TheLeagueLayout>

<style>
  .draft-predictor-page {
    display: grid;
    gap: var(--padding-lg);
  }

  .draft-predictor-header {
    display: grid;
    grid-template-columns: 1fr;
    gap: 2rem;
    justify-items: center;
    align-items: center;
    padding: 2rem;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  @media (min-width: 550px) {
    .draft-predictor-header {
      grid-template-columns: 1fr auto;
      align-items: start;
      justify-items: start;
    }
  }

  .draft-predictor-title {
    margin: 0;
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-primary-color, #111827);
  }

  .draft-predictor-subtitle {
    margin: 0;
    color: var(--text-secondary-color, #64748b);
    font-size: 1rem;
  }

  .draft-predictor-content {
    min-height: 400px;
  }

  .draft-predictor-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 400px;
    color: #64748b;
    font-size: 1.125rem;
  }

  .draft-history {
    display: grid;
    gap: 1rem;
  }

  .history-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem;
    background: #fff;
    border-radius: 0.75rem;
    box-shadow: var(--box-shadow-lg, 0 10px 15px -3px rgb(0 0 0 / 0.1));
  }

  .history-controls label {
    font-weight: 600;
    color: var(--text-primary-color, #111827);
  }

  .history-controls select {
    padding: 0.5rem 0.75rem;
    border-radius: 0.5rem;
    border: 1px solid #cbd5e1;
    background: #fff;
    min-width: 120px;
  }

  .history-table-wrapper {
    background: #fff;
    border-radius: 0.75rem;
    box-shadow: var(--box-shadow-lg, 0 10px 15px -3px rgb(0 0 0 / 0.1));
    overflow: auto;
  }

  .history-table {
    width: 100%;
    border-collapse: collapse;
  }

  .history-table thead {
    background: #f8fafc;
  }

  .history-table th,
  .history-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
    font-size: 0.95rem;
  }

  .history-table th {
    font-weight: 700;
    color: var(--text-primary-color, #111827);
  }

  .history-table td {
    color: var(--text-secondary-color, #475569);
  }

  .history-notes {
    max-width: 360px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .history-player {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .history-player__headshot {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    background: #e2e8f0;
  }

  .history-player__meta {
    display: grid;
    gap: 0.125rem;
  }

  .history-player__name {
    font-weight: 700;
    color: var(--text-primary-color, #111827);
    font-size: 0.95rem;
  }

  .history-player__sub {
    display: flex;
    align-items: center;
    gap: 0.35rem;
    color: var(--text-secondary-color, #475569);
    font-size: 0.85rem;
  }

  .history-player__logo {
    width: 18px;
    height: 18px;
    object-fit: contain;
  }

  .history-player__pos {
    font-weight: 600;
  }

  .history-team-banner {
    max-height: 35px;
    width: auto;
    display: block;
  }

  @media (max-width: 640px) {
    .history-controls {
      flex-direction: column;
      align-items: flex-start;
    }

    .history-table th,
    .history-table td {
      padding: 0.6rem 0.75rem;
      font-size: 0.85rem;
    }
  }


  .draft-predictor-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: var(--padding-md);
  }

  .info-card {
    background: var(--card-bg-color, #fff);
    border-radius: 1rem;
    padding: 1.5rem;
    box-shadow: var(--box-shadow-lg, 0 10px 15px -3px rgb(0 0 0 / 0.1));
  }

  .info-card h3 {
    margin: 0 0 1rem;
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text-primary-color, #111827);
  }

  .info-card ul {
    margin: 0;
    padding-left: 1.5rem;
    list-style: disc;
    color: var(--text-secondary-color, #64748b);
    font-size: 0.925rem;
    line-height: 1.6;
  }

  .info-card li {
    margin-bottom: 0.75rem;
  }

  .info-card li strong {
    color: var(--text-primary-color, #111827);
  }

  .info-card p {
    margin: 0;
    color: var(--text-secondary-color, #64748b);
    font-size: 0.925rem;
    line-height: 1.6;
  }

  @media (max-width: 767px) {
    .draft-predictor-title {
      font-size: 1.5rem;
    }

    .draft-predictor-subtitle {
      font-size: 0.925rem;
    }

    .draft-predictor-info {
      grid-template-columns: 1fr;
    }
  }
</style>

<script>
  const setupHistorySelect = () => {
    const yearSelect = document.getElementById('historyYear');
    const teamSelect = document.getElementById('historyTeam');
    if (yearSelect) {
      yearSelect.addEventListener('change', (e) => {
        const year = e.target.value;
        const url = new URL(window.location.href);
        url.searchParams.set('view', 'history');
        url.searchParams.set('year', year);
        if (teamSelect) {
          const team = teamSelect.value;
          if (team && team !== 'all') {
            url.searchParams.set('team', team);
          } else {
            url.searchParams.delete('team');
          }
        }
        window.location.href = url.toString();
      });
    }
    if (teamSelect) {
      teamSelect.addEventListener('change', (e) => {
        const team = e.target.value;
        const url = new URL(window.location.href);
        url.searchParams.set('view', 'history');
        url.searchParams.set('year', yearSelect ? yearSelect.value : '');
        if (team && team !== 'all') {
          url.searchParams.set('team', team);
        } else {
          url.searchParams.delete('team');
        }
        window.location.href = url.toString();
      });
    }
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupHistorySelect);
  } else {
    setupHistorySelect();
  }
</script>
