---
import TheLeagueLayout from '../layouts/TheLeagueLayout.astro';
import leagueAssets from '../data/theleague.assets.json';
import MetricCard from '../components/theleague/MetricCard.astro';
import ChartCard from '../components/theleague/ChartCard.astro';
import DonutChart from '../components/theleague/DonutChart.astro';
import type { ChartSlice } from '../scripts/chart-utils';
import {
  parseNumber,
  currencyFormatter,
  formatCapSpaceDisplay,
  formatCurrency as formatCurrencyUtil,
} from '../utils/formatters';
import {
  SALARY_CAP,
  ROSTER_LIMIT,
  TARGET_ACTIVE_COUNT,
  RESERVE_FOR_ROOKIES,
  SALARY_YEARS,
  CAP_INCLUSION,
  normalizeStatus,
  getCapPercent,
  calculateCapCharges,
  aggregateDeadMoney,
  calculateContractYearsMeta,
} from '../utils/salary-calculations';

const rosterModules = import.meta.glob('../data/mfl-player-salaries-*.json', {
  eager: true,
});
const salaryAdjustmentFeeds = import.meta.glob(
  '../data/mfl-feeds/*/salaryAdjustments.json',
  {
    eager: true,
  }
);
const leagueFeeds = import.meta.glob('../data/mfl-feeds/*/league.json', {
  eager: true,
});
const standingsFeeds = import.meta.glob('../data/mfl-feeds/*/standings.json', {
  eager: true,
});
const getModuleData = (mod) =>
  mod && typeof mod === 'object' && 'default' in mod ? mod.default : mod;

const extractSeason = (filepath) => {
  const match = filepath.match(/(\d{4})\.json$/);
  return match ? match[1] : null;
};

const extractFeedSeason = (filepath) => {
  const match = filepath.match(/mfl-feeds\/(\d{4})\//);
  return match ? match[1] : null;
};

const divisionOrder = ['Northwest', 'Southwest', 'Central', 'East'];

const teamsList = (leagueAssets.teams ?? [])
  .map((team) => ({
    id: team.id,
    name: team.name,
    division: team.division ?? '',
    icon: team.assets?.icons?.[0]?.relativePath ?? '',
  }))
  .sort((a, b) => {
    // Sort by division order first
    const divIndexA = divisionOrder.indexOf(a.division);
    const divIndexB = divisionOrder.indexOf(b.division);

    if (divIndexA !== divIndexB) {
      return divIndexA - divIndexB;
    }

    // Within same division, sort alphabetically by name
    return a.name.localeCompare(b.name);
  });

const teamLookup = Object.fromEntries(teamsList.map((team) => [team.id, team]));

const DEFAULT_HEADSHOT_URL =
  'https://www49.myfantasyleague.com/player_photos_2010/no_photo_available.jpg';
const getPlayerImageUrl = (playerId) =>
  playerId
    ? `https://www49.myfantasyleague.com/player_photos_2014/${playerId}_thumb.jpg`
    : DEFAULT_HEADSHOT_URL;

const getNflLogoUrl = (teamCode) =>
  teamCode
    ? `https://www.mflscripts.com/ImageDirectory/script-images/nflTeamsvg_2/${teamCode}.svg`
    : '';

const parseAdjustmentMeta = (description = '') => {
  const meta = {
    name: '',
    nflTeam: '',
    salary: null,
    yearsRemaining: null,
  };
  const nameMatch = description.match(/^Dropped\s+([^()]+)\s*\(/i);
  if (nameMatch) {
    meta.name = nameMatch[1].trim();
    const parts = meta.name.split(' ');
    const maybeTeam = parts[parts.length - 2];
    if (maybeTeam && maybeTeam.length === 3) meta.nflTeam = maybeTeam.toUpperCase();
  }
  const salaryMatch = description.match(/Salary:\s*\$?([\d,\.]+)/i);
  if (salaryMatch) {
    const raw = salaryMatch[1].replace(/,/g, '');
    meta.salary = Number(raw) || null;
  }
  const yearsMatch = description.match(/Years:\s*(\d+)/i);
  if (yearsMatch) meta.yearsRemaining = parseInt(yearsMatch[1], 10);
  return meta;
};

const positionOrder = ['QB', 'RB', 'WR', 'TE', 'PK', 'DEF'];
const POSITION_COLORS = {
  QB: '#6366f1', // indigo
  RB: '#f97316', // orange
  WR: '#22c55e', // green
  TE: '#14b8a6', // teal
  PK: '#0ea5e9', // light blue
  K: '#0ea5e9',
  DEF: '#475569', // slate
};
const DEAD_MONEY_SOURCES = ['deadMoney', 'salaryAdjustments'];
const rosterColumnOptions = [
  { key: 'player', label: 'Player' },
  { key: 'years', label: 'Yrs' },
  ...SALARY_YEARS.map((year, index) => ({
    key: `year${index + 1}`,
    label: String(year),
  })),
];

const nflByeWeeks = {
  ARI: null,
  ATL: null,
  BAL: null,
  BUF: null,
  CAR: null,
  CHI: null,
  CIN: null,
  CLE: null,
  DAL: null,
  DEN: null,
  DET: null,
  GB: null,
  HOU: null,
  IND: null,
  JAC: null,
  KC: null,
  LV: null,
  LAC: null,
  LAR: null,
  MIA: null,
  MIN: null,
  NE: null,
  NO: null,
  NYG: null,
  NYJ: null,
  PHI: null,
  PIT: null,
  SEA: null,
  SF: null,
  TB: null,
  TEN: null,
  WAS: null,
};
const getPositionRank = (pos) => {
  if (!pos) return positionOrder.length;
  const rank = positionOrder.indexOf(pos.toUpperCase());
  return rank === -1 ? positionOrder.length : rank;
};

const sortByPosition = (list) =>
  list.slice().sort((a, b) => {
    const diff = getPositionRank(a.position) - getPositionRank(b.position);
    if (diff !== 0) return diff;
    return parseNumber(b.salary) - parseNumber(a.salary);
  });

const annotatePositionDividers = (rows = []) => {
  const normalized = rows.map((player, index) => {
    const prevPosition =
      index > 0 ? (rows[index - 1].position ?? '').toUpperCase() : null;
    const current = (player.position ?? '').toUpperCase();
    const showDivider = (index === 0) || (index > 0 && current !== prevPosition);
    return {
      ...player,
      positionDivider: showDivider,
      _positionGroup: current,
    };
  });

  return normalized.map((player, index) => {
    const next = normalized[index + 1];
    const isEndDivider =
      !!next && (next._positionGroup ?? '') !== (player._positionGroup ?? '');
    return {
      ...player,
      positionDividerEnd: isEndDivider,
    };
  });
};

const annotateTierDividers = (rows = []) => {
  let lastTag = null;
  return rows.map((player) => {
    const currentTag = player.displayTag ?? 'active';
    const divider =
      lastTag !== null && currentTag !== lastTag && currentTag !== 'active';
    lastTag = currentTag;
    return {
      ...player,
      tierDivider: divider,
    };
  });
};

const annotateActiveStriping = (rows = []) => {
  let activeIndex = 0;
  return rows.map((player) => {
    if ((player.displayTag ?? 'active') === 'active') {
      const striped = activeIndex % 2 === 1;
      activeIndex += 1;
      return { ...player, activeStripe: striped };
    }
    return { ...player, activeStripe: false };
  });
};

// Wrapper for aggregateDeadMoney that accepts season data object
const aggregateDeadMoneyFromSeasonData = (seasonData = {}, franchiseId) => {
  const adjustments = DEAD_MONEY_SOURCES.flatMap((key) =>
    Array.isArray(seasonData[key]) ? seasonData[key] : []
  );
  return aggregateDeadMoney(adjustments, franchiseId);
};

const feedSalaryAdjustmentsBySeason = {};
Object.entries(salaryAdjustmentFeeds).forEach(([path, mod]) => {
  const season = extractFeedSeason(path);
  const data = getModuleData(mod);
  if (!season || !data?.salaryAdjustments?.salaryAdjustment) return;
  feedSalaryAdjustmentsBySeason[season] = data.salaryAdjustments.salaryAdjustment
    .map((adj) => ({
      franchiseId: adj.franchise_id ?? adj.franchiseId ?? '',
      amount: parseNumber(adj.amount),
      description: adj.description ?? '',
      yearOffset: 0, // default to current season; can enhance if offset parsing desired
      timestamp: adj.timestamp ?? null,
      ...parseAdjustmentMeta(adj.description ?? ''),
    }))
    .filter((adj) => Number.isFinite(adj.amount));
});

const leagueMetaBySeason = {};
Object.entries(leagueFeeds).forEach(([path, mod]) => {
  const season = extractFeedSeason(path);
  const data = getModuleData(mod);
  if (!season || !data?.league) return;
  const league = data.league;
  leagueMetaBySeason[season] = {
    capLimit: parseNumber(league.salaryCapAmount) || SALARY_CAP,
    rosterLimit: parseInt(league.rosterSize, 10) || ROSTER_LIMIT,
    taxiPercent: parseNumber(league.includeTaxiWithSalary) / 100 || CAP_INCLUSION.PRACTICE.current,
    irPercent: parseNumber(league.includeIRWithSalary) / 100 || CAP_INCLUSION.INJURED.current,
  };
});

const recordsBySeason = {};
Object.entries(standingsFeeds).forEach(([path, mod]) => {
  const season = extractFeedSeason(path);
  const data = getModuleData(mod);
  const rows =
    data?.leagueStandings?.franchise ??
    data?.standings?.standing ??
    data?.standings ??
    [];
  const list = Array.isArray(rows) ? rows : Object.values(rows ?? {});
  if (!season || !list.length) return;
  const toInt = (v) => {
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : 0;
  };
  const map = {};
  list.forEach((row) => {
    const id =
      row.franchise_id ??
      row.franchiseId ??
      row.id ??
      row.franchise ??
      row.team ??
      row.franchise_id1;
    if (!id) return;
    const wins =
      toInt(row.h2hw ?? row.wins ?? row.w ?? row.h2h_w ?? row.h2hwins);
    const losses =
      toInt(row.h2hl ?? row.losses ?? row.l ?? row.h2h_l ?? row.h2hlosses);
    const ties = toInt(row.h2ht ?? row.ties ?? row.t ?? row.h2h_t);
    map[id] = `${wins}-${losses}-${ties}`;
  });
  recordsBySeason[season] = map;
});

const buildDisplayRows = (teamData) => {
  const mapPlayers = (players = [], displayTag = 'active') =>
    sortByPosition(players).map((player) => ({
      ...player,
      displayTag,
      byeWeek: player.byeWeek ?? nflByeWeeks[player.nflTeam ?? ''] ?? null,
    }));

  const combined = [
    ...mapPlayers(teamData.players ?? [], 'active'),
    ...mapPlayers(teamData.practiceSquad ?? [], 'practice'),
    ...mapPlayers(teamData.injuredReserve ?? [], 'injured'),
  ];

  const withDividers = annotateTierDividers(annotatePositionDividers(combined));
  return annotateActiveStriping(withDividers);
};

const buildSeasonPayload = (season, rawData) => {
  const players = (rawData?.players ?? []).map((player) => {
    const salary = parseNumber(player.salary);
    const contractYears =
      Number.parseInt(player.contractYear ?? player.contractYearRemaining ?? '0', 10) ||
      0;
    const franchiseId = player.franchiseId ?? 'FA';
    const totalRemaining = salary * Math.max(contractYears || 1, 1);
    const seasonYear = Number.parseInt(season, 10) || new Date().getFullYear();
    const contractType =
      player.contractType ??
      (player.status && player.status !== 'ROSTER'
        ? player.status
        : player.draftYear && seasonYear - Number(player.draftYear) <= 2
          ? 'Rookie'
          : 'Standard');
    const nflTeam = (player.team ?? '').toUpperCase();

    return {
      id: player.id,
      name: player.name,
      position: player.position ?? 'N/A',
      salary,
      contractYears,
      totalRemaining,
      franchiseId,
      status: player.status ?? 'ROSTER',
      contractType,
      points: parseNumber(player.points),
      nflTeam,
      draftYear: player.draftYear ?? null,
      headshot: getPlayerImageUrl(player.id),
      nflLogo: getNflLogoUrl(nflTeam),
      rosterSlot: normalizeStatus(player.status),
      byeWeek: nflByeWeeks[nflTeam] ?? null,
    };
  });

  const grouped = {};
  players.forEach((player) => {
    const key = player.franchiseId || 'FA';
    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(player);
  });

  const teams = {};

  Object.entries(grouped).forEach(([teamId, teamPlayers]) => {
    const buckets: { ACTIVE: typeof players; PRACTICE: typeof players; INJURED: typeof players } = {
      ACTIVE: [],
      PRACTICE: [],
      INJURED: [],
    };
    (Array.isArray(teamPlayers) ? teamPlayers : []).forEach((player) => {
      if (player.status === 'TAXI_SQUAD') {
        buckets.PRACTICE.push(player);
      } else if (player.status === 'INJURED_RESERVE') {
        buckets.INJURED.push(player);
      } else {
        buckets.ACTIVE.push(player);
      }
    });
    const activeSorted = sortByPosition(buckets.ACTIVE);
    const practiceSorted = sortByPosition(buckets.PRACTICE);
    const injuredSorted = sortByPosition(buckets.INJURED);

    // Calculate total salary: ACTIVE @ 100%, INJURED @ 100%, PRACTICE @ 50%
    const activeSalary = activeSorted.reduce(
      (sum, player) => sum + parseNumber(player.salary),
      0
    );
    const injuredSalary = injuredSorted.reduce(
      (sum, player) => sum + parseNumber(player.salary),
      0
    );
    const practiceSalary = practiceSorted.reduce(
      (sum, player) => sum + parseNumber(player.salary) * 0.5,
      0
    );
    const totalSalary = activeSalary + injuredSalary + practiceSalary;
    teams[teamId] = {
      players: activeSorted,
      practiceSquad: practiceSorted,
      injuredReserve: injuredSorted,
      record: recordsBySeason[season]?.[teamId] ?? null,
      totals: {
        totalSalary,
        rosterCount: activeSorted.length,
        openSpots: Math.max(ROSTER_LIMIT - activeSorted.length, 0),
        practiceCount: practiceSorted.length,
        injuredCount: injuredSorted.length,
      },
    };
  });

  return {
    metadata: {
      capLimit: leagueMetaBySeason[season]?.capLimit ?? SALARY_CAP,
      rosterLimit: leagueMetaBySeason[season]?.rosterLimit ?? ROSTER_LIMIT,
      season,
    },
    teams,
    salaryAdjustments: feedSalaryAdjustmentsBySeason[season] ?? [],
  };
};

const rostersBySeason = {};
Object.entries(rosterModules).forEach(([path, mod]) => {
  const season = extractSeason(path);
  if (!season) return;
  rostersBySeason[season] = buildSeasonPayload(season, getModuleData(mod));
});

const seasonOptions = Object.keys(rostersBySeason).sort(
  (a, b) => Number(b) - Number(a)
);
const defaultSeason = seasonOptions[0] ?? seasonOptions.at(-1) ?? '2025';
const defaultTeamId =
  teamsList[0]?.id ??
  (Object.keys(rostersBySeason[defaultSeason]?.teams ?? {})[0] ?? 'FA');

const initialSeasonData = rostersBySeason[defaultSeason] ?? { teams: {} };
const initialTeamData =
  initialSeasonData.teams?.[defaultTeamId] ?? {
    players: [],
    practiceSquad: [],
    injuredReserve: [],
    record: null,
    totals: {
      totalSalary: 0,
      rosterCount: 0,
      openSpots: ROSTER_LIMIT,
      practiceCount: 0,
      injuredCount: 0,
    },
  };
const initialCapLimit = initialSeasonData?.metadata?.capLimit ?? SALARY_CAP;
const initialRosterLimit = initialSeasonData?.metadata?.rosterLimit ?? ROSTER_LIMIT;

const calculateYearTotals = (
  rows: Array<{ contractYears: number; salary?: number; displayTag?: string; status?: string }> = []
) =>
  SALARY_YEARS.map((_, index) =>
    rows.reduce((sum, player) => {
      if ((player.contractYears ?? 0) > index) {
        const isCurrent = index === 0;
        const tagRaw = (player.displayTag ?? player.status ?? 'ACTIVE').toString().toUpperCase();
        const tag = tagRaw.includes('PRACTICE')
          ? 'PRACTICE'
          : tagRaw.includes('INJURED') || tagRaw === 'IR'
            ? 'INJURED'
            : 'ACTIVE';
        const percent = getCapPercent(tag, isCurrent);
        const baseSalary = parseNumber(player.salary ?? 0);
        const salaryForYear = baseSalary; // use the explicit salary provided for that season
        return sum + (salaryForYear * percent || 0);
      }
      return sum;
    }, 0)
  );

const initialRosterRows = buildDisplayRows(initialTeamData);
const initialYearTotals = calculateYearTotals(initialRosterRows);
const initialCapCharges = calculateCapCharges(initialRosterRows);
const initialDeadMoney = aggregateDeadMoneyFromSeasonData(initialSeasonData, defaultTeamId);
const initialCapChargesWithDead = initialCapCharges.map(
  (val, idx) => val + (initialDeadMoney[idx] ?? 0)
);
const initialCapCharge = initialCapChargesWithDead[0] ?? 0;
const initialNextYearCapCharge = initialCapChargesWithDead[1] ?? 0;
const initialActiveCount =
  initialTeamData.players?.length ??
  initialTeamData.totals?.rosterCount ??
  0;
const {
  contractYearsTotal: initialContractYearsTotal,
  longestContract: initialLongestContract,
} = calculateContractYearsMeta(initialRosterRows);
const initialPlayersNextYear = initialRosterRows.filter((p) => (p.contractYears ?? 0) > 1).length;
const initialRemainingSlots2026 = Math.max(TARGET_ACTIVE_COUNT - initialPlayersNextYear, 1);
const initialPlayersToCut2026 = Math.max(initialPlayersNextYear - TARGET_ACTIVE_COUNT, 0);
const initialPlayersToCutToSign2026 = Math.max(initialPlayersNextYear - TARGET_ACTIVE_COUNT + 1, 0);
const initialNeedsToCutToSign2026 = initialPlayersNextYear >= TARGET_ACTIVE_COUNT;
const initialDeadMoney2026 = initialDeadMoney[1] ?? 0;
const initialCapSpace2026 =
  (initialSeasonData?.metadata?.capLimit ?? initialCapLimit) -
  (initialCapChargesWithDead[1] ?? 0) -
  RESERVE_FOR_ROOKIES;
const initialAvgPerPlayer2026 = Math.max(initialCapSpace2026, 0) / initialRemainingSlots2026;
const initialLastContractYear = (parseInt(defaultSeason, 10) || SALARY_YEARS[0]) + (initialLongestContract || 0) - 1;

const formatCurrency = (value) => currencyFormatter.format(value ?? 0);

// Prepare initial chart data for SSR
// Note: These are placeholder slices - actual data will be calculated client-side in updateView()
const initialCapSlices: ChartSlice[] = [];
const initialRosterSlices: ChartSlice[] = [];
const initialPositionSlices: ChartSlice[] = [];

const serializedConfig = JSON.stringify({
  seasons: rostersBySeason,
  seasonOptions,
  defaultSeason,
  defaultTeamId,
  initialSeasonData,
  initialTeamData,
  adjustmentsBySeason: feedSalaryAdjustmentsBySeason,
  teams: teamLookup,
  rosterLimit: ROSTER_LIMIT,
  positionOrder,
  columnOptions: rosterColumnOptions,
  salaryYears: SALARY_YEARS,
  byeWeeks: nflByeWeeks,
  capLimit: initialCapLimit,
  rosterLimitOverride: initialRosterLimit,
  capInclusion: CAP_INCLUSION,
  deadMoneySources: DEAD_MONEY_SOURCES,
  positionColors: POSITION_COLORS,
  targetActiveCount: TARGET_ACTIVE_COUNT,
  reserveForRookies: RESERVE_FOR_ROOKIES,
});
---

<TheLeagueLayout title="Team Rosters">
  <section class="roster-page">
    <header class="roster-page__header">
      <div>
        <p class="eyebrow">Contracts &amp; Cap</p>
        <h1>Team Rosters</h1>
      </div>
      
    </header>

    <div class="roster-controls">
      <div class="team-icon-nav">
        {divisionOrder.map((division) => {
          const divisionTeams = teamsList.filter(team => team.division === division);
          return divisionTeams.length > 0 ? (
            <div class="division-group">
              <div class="division-label">{division}</div>
              <div class="division-teams">
                {divisionTeams.map((team) => (
                  <button
                    class="team-icon-btn"
                    data-team-id={team.id}
                    data-active={team.id === defaultTeamId}
                    title={team.name}
                    aria-label={`View ${team.name} roster`}
                  >
                    {team.icon && (
                      <img
                        src={team.icon}
                        alt={`${team.name} icon`}
                        class="team-icon-img"
                      />
                    )}
                  </button>
                ))}
              </div>
            </div>
          ) : null;
        })}
      </div>
      <input type="hidden" id="rosterSeasonSelect" value={defaultSeason} />
      <input type="hidden" id="rosterTeamSelect" value={defaultTeamId} />
    </div>

    <div class="roster-table-card">
    <div class="team-card roster-card" data-team-identity>
      {teamLookup[defaultTeamId]?.icon && (
        <img
          src={teamLookup[defaultTeamId]?.icon}
          alt={`${teamLookup[defaultTeamId]?.name ?? 'Team'} icon`}
        />
      )}
      <div>
        <p class="team-card__label">Active Roster</p>
        <h2 data-team-name>
          {teamLookup[defaultTeamId]?.name ?? 'Franchise'}
        </h2>
        <p data-team-meta>
          {teamLookup[defaultTeamId]?.division
            ? `${teamLookup[defaultTeamId]?.division} Division`
            : 'Independent'}
        </p>
      </div>
    </div>
      <div class="roster-table-wrapper">
        <table class="roster-table" data-hidden-columns="">
          <thead>
            <tr>
              <th scope="col" data-column="player">Player</th>
              <th scope="col" data-column="years">Yrs</th>
              {SALARY_YEARS.map((year, index) => (
                <th scope="col" data-column={`year${index + 1}`}>{year}</th>
              ))}
            </tr>
          </thead>
          <tfoot>
            <tr class="roster-totals">
              <td data-column="player" class="roster-totals__label">Total Salary</td>
              <td data-column="years"></td>
              {SALARY_YEARS.map((year, index) => (
                <td data-column={`year${index + 1}`} id={`yearTotal${index + 1}`}>
                  {formatCurrency(initialYearTotals[index] ?? 0)}
                </td>
              ))}
            </tr>
            <tr class="roster-totals roster-totals--dead">
              <td data-column="player" class="roster-totals__label">Dead Money</td>
              <td data-column="years"></td>
              {SALARY_YEARS.map((year, index) => (
                <td data-column={`dm${index + 1}`} id={`dmTotal${index + 1}`}>
                  {formatCurrency(initialDeadMoney[index] ?? 0)}
                </td>
              ))}
            </tr>
            <tr class="roster-totals roster-totals--cap">
              <td data-column="player" class="roster-totals__label">Salary Cap</td>
              <td data-column="years"></td>
              {SALARY_YEARS.map((year, index) => (
                <td data-column={`cap${index + 1}`} id={`capLimit${index + 1}`}>
                  {formatCurrency(initialCapLimit)}
                </td>
              ))}
            </tr>
            <tr class="roster-totals roster-totals--space">
              <td data-column="player" class="roster-totals__label">Cap Space</td>
              <td data-column="years"></td>
              {SALARY_YEARS.map((year, index) => (
                <td data-column={`space${index + 1}`} id={`capSpaceTotal${index + 1}`}>
                  {formatCurrency(
                    (index === 0 ? initialCapLimit : initialCapLimit) -
                      ((initialYearTotals[index] ?? 0) + (initialDeadMoney[index] ?? 0))
                  )}
                </td>
              ))}
            </tr>
          </tfoot>
          <tbody id="rosterTableBody">
          {initialRosterRows.length ? (
            initialRosterRows.map((player) => (
              <tr
                data-player-id={player.id}
                class={`roster-row roster-row--${player.displayTag ?? 'active'}${player.positionDivider ? ' roster-row--position-divider' : ''}${player.positionDividerEnd ? ' roster-row--position-divider-end' : ''}${player.tierDivider ? ' roster-row--tier-divider' : ''}${player.activeStripe ? ' roster-row--active-alt' : ''}`}
              >
                <td data-label="Player" data-column="player">
                  <div class="player-cell">
                    <div class="player-cell__avatar">
                      <img
                        src={player.headshot ?? DEFAULT_HEADSHOT_URL}
                        alt={`${player.name} headshot`}
                        loading="lazy"
                        decoding="async"
                        onerror={`this.onerror=null;this.src='${DEFAULT_HEADSHOT_URL}';`}
                      />
                    </div>
                    <div>
                      <strong>{player.name}</strong>
                      <div class="player-meta">
                        {player.position?.toUpperCase() !== 'DEF' && player.nflLogo && (
                          <img
                            src={player.nflLogo}
                            alt={`${player.nflTeam ?? 'FA'} logo`}
                            class="player-meta__logo"
                            loading="lazy"
                            decoding="async"
                          />
                        )}
                        {player.position && <span class="player-meta__pos">{player.position}</span>}
                      </div>
                    </div>
                  </div>
                </td>
                <td data-label="Yrs" data-column="years">{player.contractYears || 0}</td>
                {SALARY_YEARS.map((year, index) => {
                  const isUfa = !(player.contractYears > index);
                  const isFirstYearUfa = isUfa && player.contractYears === index;
                  const isFutureUfa = isUfa && player.contractYears < index;

                  let displayValue;
                  let cellClass = 'salary-cell';

                  if (isFirstYearUfa) {
                    displayValue = 'UFA';
                    cellClass += ' salary-cell--ufa';
                  } else if (isFutureUfa) {
                    displayValue = '—';
                    cellClass += ' salary-cell--future-ufa';
                  } else {
                    displayValue = formatCurrency(player.salary ?? 0);
                  }

                  return (
                    <td
                      data-label={year}
                      data-column={`year${index + 1}`}
                      class={cellClass}
                    >
                      {displayValue}
                    </td>
                  );
                })}
              </tr>
            ))
          ) : (
            <tr>
              <td colspan={2 + SALARY_YEARS.length} class="roster-empty">
                This franchise has no players recorded for this season snapshot.
              </td>
            </tr>
          )}
          </tbody>
        </table>
      </div>
      <div class="roster-legend">
        <span>
          <span class="legend-swatch legend-swatch--active"></span>
          Active Roster
        </span>
        <span>
          <span class="legend-swatch legend-swatch--practice"></span>
          Practice Squad
        </span>
        <span>
          <span class="legend-swatch legend-swatch--injured"></span>
          Injured Reserve
        </span>
      </div>
    </div>

    <div class="team-card" data-team-identity>
      {teamLookup[defaultTeamId]?.icon && (
        <img
          src={teamLookup[defaultTeamId]?.icon}
          alt={`${teamLookup[defaultTeamId]?.name ?? 'Team'} icon`}
        />
      )}
      <div>
        <p class="team-card__label">Advanced Analytics</p>
        <h2 data-team-name>
          {teamLookup[defaultTeamId]?.name ?? 'Franchise'}
        </h2>
        <p data-team-meta>
          Advanced Analytics
        </p>
      </div>
    </div>

    <div class="chart-grid">
      <ChartCard title="Cap Allocation" subtitle="Current season cap usage by bucket">
        <DonutChart chartId="capDonut" slices={initialCapSlices} />
      </ChartCard>
      <ChartCard title="Roster Composition" subtitle="Active vs IR vs Practice vs Open slots">
        <DonutChart chartId="rosterDonut" slices={initialRosterSlices} />
      </ChartCard>
      <ChartCard title="Position Allocation" subtitle="Current season cap by position">
        <DonutChart chartId="posDonut" slices={initialPositionSlices} showLegend={true} />
      </ChartCard>
    </div>
    <div class="chart-card chart-card--sub">
      <div class="chart-card__header">
        <h3>Cap Subtotals (Current Season)</h3>
        <p class="chart-card__sub">Active, IR, Practice, and Dead Money</p>
      </div>
      <div class="cap-subtotals">
        <div class="cap-subtotals__row">
          <span>
            <span class="legend-dot legend-active"></span>
            Active Roster <span id="countActive" class="cap-count"></span>
          </span>
          <strong id="subtotalActive">$0</strong>
        </div>
        <div class="cap-subtotals__row">
          <span>
            <span class="legend-dot legend-practice"></span>
            Practice Squad <span id="countPractice" class="cap-count"></span>
          </span>
          <strong id="subtotalPractice">$0</strong>
        </div>
        <div class="cap-subtotals__row">
          <span>
            <span class="legend-dot legend-injured"></span>
            Injured Reserve <span id="countInjured" class="cap-count"></span>
          </span>
          <strong id="subtotalInjured">$0</strong>
        </div>
        <div class="cap-subtotals__row">
          <span><span class="legend-dot legend-dead"></span>Dead Money</span>
          <strong id="subtotalDead">$0</strong>
        </div>
        <div class="cap-subtotals__row">
          <span><span class="legend-dot legend-capspace"></span>Cap Space</span>
          <strong id="subtotalCapSpace">$0</strong>
        </div>
      </div>
    </div>
    <h3 class="chart-metrics__headline">2026 at a glance</h3>
    <div class="chart-metrics">
      <MetricCard
        label="Cap Space"
        value={formatCapSpaceDisplay(Math.max(initialCapLimit - initialNextYearCapCharge, 0))}
        valueId="summaryCapNext"
      />
      <MetricCard
        label="Avg per Player*"
        value={`${formatCurrency(initialAvgPerPlayer2026)} × ${initialRemainingSlots2026}`}
        valueId="summaryAvg2026"
      />
      <MetricCard
        label="Players Signed"
        value={String(initialPlayersNextYear)}
        valueId="summaryPlayersNext"
        hint={initialPlayersToCut2026 > 0 ? `Must cut ${initialPlayersToCut2026} ${initialPlayersToCut2026 === 1 ? 'player' : 'players'} by cutdown` : undefined}
        hintVariant="error"
        hintId="needsToCutRoster2026"
      />
      <MetricCard
        label="Dead Money"
        value={formatCurrency(initialDeadMoney2026)}
        valueId="summaryDeadMoney2026"
      />
    </div>
    <small class="chart-metrics__hint">*Based on filling to {TARGET_ACTIVE_COUNT} active players. Reserves {formatCurrency(RESERVE_FOR_ROOKIES)} for practice squad rookies and free agents.</small>
    <div class="roster-table-card roster-table-card--sub">
      <div class="roster-table-card__header">
        <div>
          <h3>Cap Hits / Dead Money</h3>
          <p>Includes drops/buyouts for the selected franchise.</p>
        </div>
      </div>
      <div class="roster-table-wrapper">
        <table class="roster-table roster-table--compact">
          <thead>
            <tr>
              <th scope="col" data-column="player" class="deadmoney-player-heading">Player/Adjustment</th>
              {SALARY_YEARS.map((year, index) => (
                <th scope="col" data-column={`dm-year${index + 1}`}>{year}</th>
              ))}
            </tr>
          </thead>
          <tbody id="deadMoneyTableBody">
            <tr>
              <td colspan={1 + SALARY_YEARS.length} class="roster-empty">
                No cap hits recorded for this franchise.
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
</TheLeagueLayout>

<style>
  .roster-page {
    display: flex;
    flex-direction: column;
    gap: var(--padding-lg);
  }

  .eyebrow {
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-size: 0.8rem;
    color: #64748b;
    margin-bottom: 0.25rem;
  }

  .roster-page__header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: var(--padding-md);
    flex-wrap: wrap;
  }

  .roster-page__actions {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.65rem 1.4rem;
    border-radius: 999px;
    border: none;
    background: #2563eb;
    color: #fff;
    font-weight: 600;
    text-decoration: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--box-shadow-btn-hover);
  }

  .btn-secondary {
    background: #e5e7eb;
    color: #111827;
    cursor: not-allowed;
  }

  .roster-controls {
    display: flex;
    justify-content: center;
    margin-bottom: 1.5rem;
  }

  .team-icon-nav {
    display: flex;
    gap: var(--padding-md);
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    max-width: 100%;
    background-color: var(--card-bg-color);
    box-shadow: var(--box-shadow-md);
    border-radius: 5px;
  }

  .division-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: center;
  }

  .division-label {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #94a3b8;
    margin-bottom: 0.25rem;
  }

  .division-teams {
    display: flex;
    gap: 0.5rem;
    flex-wrap: nowrap;
    align-items: center;
  }

  .team-icon-btn {
    width: 50px;
    height: 50px;
    padding: 0.25rem;
    border: 2px solid transparent;
    border-radius: 0.5rem;
    background: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .team-icon-btn:hover {
    border-color: var(--secondary-color, #2e8743);
    transform: scale(1.1);
  }

  .team-icon-btn[data-active="true"] {
    border-color: var(--primary-color, #1c497c);
    background: #f0f9ff;
    box-shadow: var(--box-shadow-focus-ring);
  }

  .team-icon-img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  @media (max-width: 768px) {
    .team-icon-btn {
      width: 45px;
      height: 45px;
    }
  }

  @media (max-width: 480px) {
    .team-icon-btn {
      width: 40px;
      height: 40px;
    }

    .team-icon-nav {
      gap: 0.4rem;
    }
  }

  .team-card {
    display: flex;
    align-items: center;
    gap: var(--padding-md);
    padding: var(--padding-lg);
    border-radius: 1rem;
    background: #fff;
    box-shadow: var(--box-shadow-lg);
  }
  .team-card.roster-card {
    box-shadow: none;
    border-radius: none;
  }

  .team-card img {
    width: 90px;
    height: 90px;
    border-radius: 14px;
    object-fit: cover;
  }

  .team-card__label {
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.1em;
    color: #94a3b8;
    margin: 0;
  }

  .team-card h2 {
    margin: 0;
    font-size: 1.6rem;
  }

  .team-card p {
    margin: 0;
    color: #64748b;
  }

  .roster-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: var(--padding-md);
  }

  .roster-summary article {
    background: #fff;
    border-radius: 1rem;
    padding: var(--padding-md) var(--padding-md) var(--padding-xl);
    box-shadow: var(--box-shadow-md);
  }

  .roster-summary p {
    margin: 0;
    color: #6b7280;
  }

  .roster-summary strong {
    display: block;
    margin-top: 0.35rem;
    font-size: clamp(1.1rem, 4vw, 1.6rem);
    line-height: 1.2;
  }

  .roster-table-card {
    background: #fff;
    border-radius: 1rem;
    padding: var(--padding-md);
    box-shadow: var(--box-shadow-lg);
  }

  .roster-table-card--sub {
    padding: var(--padding-md);
  }

  .chart-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: var(--padding-md);
  }

  .chart-card {
    background: var(--card-bg-color, #fff);
    border-radius: 1rem;
    padding: var(--padding-md);
    box-shadow: var(--box-shadow-lg, 0 10px 15px -3px rgb(0 0 0 / 0.1));
    display: grid;
    gap: 0.75rem;
  }

  .chart-card__header h3 {
    margin: 0;
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text-primary-color, #111827);
  }

  .chart-card__sub {
    margin: 0.15rem 0 0;
    color: var(--text-secondary-color, #64748b);
    font-size: 0.9rem;
  }

  .cap-subtotals {
    display: grid;
    gap: 0.35rem;
  }

  .cap-subtotals__row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 0.95rem;
    color: #1f2937;
    border-bottom: 1px solid #f7f7f7;
    padding-bottom: var(--padding-xs);
  }

  .cap-subtotals__row strong {
    font-size: 0.95rem;
  }

  .cap-count {
    font-weight: 600;
    margin-left: 0.35rem;
    color: #475569;
    font-size: 0.9rem;
  }

  .legend-dot {
    display: inline-block;
    width: 0.75rem;
    height: 0.75rem;
    border-radius: 999px;
    margin-right: 0.35rem;
  }

  .legend-active {
    background: #16a34a;
  }
  .legend-practice {
    background: #2563eb;
  }
  .legend-injured {
    background: #dc2626;
  }
  .legend-dead {
    background: #4b5563;
  }
  .legend-capspace {
    background: #22c55e;
    opacity: 0.5;
  }

  .deadmoney-row td {
    font-size: 0.75rem;
  }

  .chart-metrics {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 0.75rem;
  }

  .chart-metrics__hint {
    color: #6b7280;
    font-size: 0.8rem;
  }

  .chart-metrics__headline {
    margin: 0;
    font-size: 1.25rem;
  }

  .roster-table-card__header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }

  .roster-table-card__header h3 {
    margin: 0;
  }

  #rosterCountLabel {
    font-weight: 600;
    color: #2563eb;
    background: #dbeafe;
    padding: 0.35rem 0.85rem;
    border-radius: 999px;
  }

  .column-controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    font-size: 0.9rem;
    color: #475569;
  }

  .column-controls span {
    font-weight: 600;
  }

  .column-controls label {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    background: #f1f5f9;
    border-radius: 999px;
    padding: 0.2rem 0.75rem;
    font-weight: 600;
  }

  .column-controls input {
    accent-color: #2563eb;
  }

  .roster-table-wrapper {
    width: 100%;
    overflow-x: auto;
  }

  .roster-table {
    width: 100%;
    min-width: 980px;
    border-collapse: collapse;
  }

  .roster-table--compact {
    min-width: auto;
  }

  .roster-table--compact th,
  .roster-table--compact td {
    font-size: 0.85rem;
  }

  .roster-table th {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #94a3b8;
    padding: 0.5rem;
    border-bottom: 1px solid #e2e8f0;
    text-align: right;
  }

  .roster-table td {
    padding: 0.75rem 0.5rem;
    border-bottom: 1px solid #f1f5f9;
    vertical-align: middle;
  }


  :global(.roster-table th[data-column='player']) {
    text-align: left !important;
  }
  :global(.roster-table td[data-column='player']) {
    text-align: left !important;
    padding-left: 0.75rem;
    padding-block: 0.25rem;
    font-size: .9rem;
  }

  .deadmoney-player-heading {
    text-align: left !important;
  }

:global(.roster-table th.deadmoney-player-heading) {
  text-align: left !important;
  padding-left: 0.75rem;
}

.deadmoney-player-cell {
  text-align: left !important;
  padding-left: 0.75rem;
}

:global(.roster-table th[data-column='years']),
:global(.roster-table td[data-column='years']) {
  width: 60px;
  text-align: center;
}

  :global(.roster-table td[data-column^='year']) {
    font-size: 0.75rem;
    text-align: right;
    padding-right: 0.5rem;
  }

:global(.roster-table th[data-column^='year']) {
  text-align: right;
  padding-right: 0.5rem;
}

  :global(.salary-cell) {
    text-align: right;
    padding-right: 0.5rem;
  }

  :global(.salary-cell--ufa) {
    text-align: center;
    color: #dc2626;
    font-weight: 600;
  }

  :global(.salary-cell--future-ufa) {
    text-align: center;
    color: #9ca3af;
    font-weight: 400;
  }

  .roster-table tfoot td {
    border-top: 2px solid #e2e8f0;
    border-bottom: none;
    font-weight: 600;
    background: #f8fafc;
  }

  .roster-totals__label {
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-size: 0.75rem;
    color: #475569;
    text-align: left;
    padding-left: 0.75rem;
  }

  .roster-totals,
  .roster-totals td {
    font-size: 0.75rem;
    font-weight: 700;
    text-align: right;
  }

  .roster-totals td[data-column='player'] {
    text-align: right;
  }

:global(.player-meta) {
  display: flex;
  align-items: center;
  gap: 0.35rem;
  font-size: 0.85rem;
  color: #6b7280;
}

:global(.player-meta span) {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-weight: 100;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}

:global(.player-meta__pos) {
  font-weight: 300;
  color: #475569;
  text-transform: uppercase;
  letter-spacing: 0.04em;
}

:global(.player-meta__logo) {
  width: 1rem;
  height: 1rem;
  flex-shrink: 0;
  object-fit: contain;
  }


  :global(.roster-table[data-hidden-columns~='player'] th[data-column='player']),
  :global(.roster-table[data-hidden-columns~='player'] td[data-column='player']),
  :global(.roster-table[data-hidden-columns~='years'] th[data-column='years']),
  :global(.roster-table[data-hidden-columns~='years'] td[data-column='years']),
  :global(.roster-table[data-hidden-columns~='year1'] th[data-column='year1']),
  :global(.roster-table[data-hidden-columns~='year1'] td[data-column='year1']),
  :global(.roster-table[data-hidden-columns~='year2'] th[data-column='year2']),
  :global(.roster-table[data-hidden-columns~='year2'] td[data-column='year2']),
  :global(.roster-table[data-hidden-columns~='year3'] th[data-column='year3']),
  :global(.roster-table[data-hidden-columns~='year3'] td[data-column='year3']),
  :global(.roster-table[data-hidden-columns~='year4'] th[data-column='year4']),
  :global(.roster-table[data-hidden-columns~='year4'] td[data-column='year4']),
  :global(.roster-table[data-hidden-columns~='year5'] th[data-column='year5']),
  :global(.roster-table[data-hidden-columns~='year5'] td[data-column='year5']) {
    display: none;
  }

  :global(.deadmoney-row td) {
    padding-block: 0.25rem;
    font-size: 0.75rem;
    text-align: right;
  }

  :global(.deadmoney-row) {
    border-left: 0;
    background: var(--color-bg-base, #fff);
  }

  :global(.deadmoney-row--alt) {
    background: var(--color-bg-subtle, #f7f8fb);
  }

  :global(.player-cell) {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  :global(.player-cell__avatar) {
    width: 2rem;
    height: 2rem;
    border-radius: 999px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  :global(.player-cell__avatar img) {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  :global(.player-cell__avatar--def img) {
    object-fit: contain;
    border: 0;
    background: transparent;
  }
  :global(.player-cell__avatar--def) {
    border: 0;
    background: transparent;
  }
  :global(.player-cell__avatar--dm) {
    background: #fff7ed;
    border-color: #fed7aa;
    color: #c2410c;
    font-weight: 700;
    font-size: 0.75rem;
  }

  :global(.player-cell__nfl-icon) {
    width: 1rem;
    height: 1rem;
    margin-left: 0.4rem;
    vertical-align: middle;
    object-fit: contain;
  }

  :global(.player-cell__meta) {
    display: block;
    font-size: 0.8rem;
    color: #94a3b8;
  }

  :global(.pill) {
    display: inline-flex;
    align-items: center;
    padding: 0.15rem 0.9rem;
    border-radius: 999px;
    background: #dbeafe;
    color: #1e3a8a;
    font-size: 0.85rem;
    font-weight: 600;
    margin-right: 0.35rem;
  }

  :global(.contract-years) {
    color: #475569;
    font-weight: 600;
  }

  .timeline-header {
    text-align: right;
  }

  .timeline-header div {
    display: grid;
    grid-template-columns: repeat(7, minmax(70px, 1fr));
    gap: 0.35rem;
    font-size: 0.75rem;
    color: #94a3b8;
  }

  :global(.timeline-row) {
    display: grid;
    grid-template-columns: repeat(7, minmax(70px, 1fr));
    gap: 0.35rem;
  }

  :global(.roster-empty) {
    text-align: center;
    padding: 2rem 1rem;
    color: #94a3b8;
  }

  :global(.roster-row) {
    border-left: 4px solid transparent;
    transition: background 0.15s ease;
  }

  :global(.roster-row--active) {
    border-left-color: #16a34a;
    background: var(--color-bg-base, #fff);
  }

  :global(.roster-row--active-alt) {
    background: var(--color-bg-subtle, #f7f8fb);
  }

  :global(.roster-row--practice) {
    border-left-color: #2563eb;
    background: var(--color-bg-practice, #f0f7ff);
  }

  :global(.roster-row--practice:nth-of-type(even)) {
    background: var(--color-bg-practice-alt, #e0efff);
  }

  :global(.roster-row--injured) {
    border-left-color: #dc2626;
    background: var(--color-bg-injured, #fff5f5);
  }

  :global(.roster-row--injured:nth-of-type(even)) {
    background: var(--color-bg-injured-alt, #ffe8e8);
  }

  :global(.roster-row--position-divider) {
    border-top: 2px solid #e2e8f0;
  }

  :global(.roster-row--active.roster-row--position-divider td), :global(.roster-table tbody tr:first-child td[data-column="player"])  {
    padding-top: 0.5rem;
  }
  :global(.roster-row--active.roster-row--position-divider-end td) {
    padding-bottom: 0.5rem;
  }
  :global(.roster-row--practice.roster-row--position-divider-end td) {
    padding-bottom: 0.75rem;
    border-bottom: 3px solid var(--color-border-practice, #bfdbfe);
  }
  :global(.roster-row--injured.roster-row--position-divider-end td) {
    padding-bottom: 0.75rem;
    
  }

  :global(.roster-row--tier-divider td) {
    padding-top: 0.75rem;
  }

  :global(.roster-row--practice.roster-row--tier-divider td) {
    border-top: 3px solid var(--color-border-practice, #bfdbfe);
        padding-top: 0.5rem;
  }

  :global(.roster-row--injured.roster-row--tier-divider td) {
    border-top: 3px solid var(--color-border-injured, #fecaca);
        padding-top: 0.5rem;
  }

  .roster-legend {
    display: flex;
    gap: 1.5rem;
    margin-top: 0.85rem;
    font-size: 0.9rem;
    color: #475569;
  }

  .legend-swatch {
    display: inline-block;
    width: 0.75rem;
    height: 0.75rem;
    border-radius: 999px;
    margin-right: 0.35rem;
  }

  .legend-swatch--active {
    background: #16a34a;
  }

  .legend-swatch--practice {
    background: #2563eb;
  }

  .legend-swatch--injured {
    background: #dc2626;
  }

  .deadmoney-row__amount {
    text-align: right;
  }


  @media (max-width: 900px) {
    .roster-table {
      min-width: 720px;
    }
  }

  @media (max-width: 640px) {
    .roster-table th,
    .roster-table td {
      font-size: 0.85rem;
    }
  }
</style>

<script
  type="application/json"
  id="roster-config"
  set:html={serializedConfig}
></script>

<script type="module">
  const config = JSON.parse(
    document.getElementById('roster-config').textContent
  );

  const initRosterPage = () => {
    const {
      seasons = {},
      defaultSeason,
      defaultTeamId,
      initialSeasonData: initialSeasonDataConfig,
      initialTeamData: initialTeamDataConfig,
      adjustmentsBySeason = {},
      teams = {},
      rosterLimit,
      positionOrder = ['QB', 'RB', 'WR', 'TE', 'PK', 'DEF'],
      columnOptions = [],
      salaryYears = [],
      byeWeeks = {},
      capLimit = 45_000_000,
      capInclusion = {},
      deadMoneySources = [],
      rosterLimitOverride,
      positionColors = {},
      targetActiveCount = 22,
      reserveForRookies = 5_000_000,
    } = config;

    const formatCurrency = new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      maximumFractionDigits: 0,
    });

    const formatCapSpaceText = (value = 0) => {
      if (!Number.isFinite(value)) return formatCurrency.format(0);
      if (value >= 1_000_000) {
        const millions = value / 1_000_000;
        return `$${millions.toFixed(1)} million`;
      }
      return formatCurrency.format(value);
    };

    const DEFAULT_HEADSHOT_URL =
      'https://www49.myfantasyleague.com/player_photos_2010/no_photo_available.jpg';
    const buildPlayerImageUrl = (playerId) =>
      playerId
        ? `https://www49.myfantasyleague.com/player_photos_2014/${playerId}_thumb.jpg`
        : DEFAULT_HEADSHOT_URL;

    const buildNflLogoUrl = (teamCode) =>
      teamCode
        ? `https://www.mflscripts.com/ImageDirectory/script-images/nflTeamsvg_2/${teamCode}.svg`
        : '';

    const seasonSelect = document.getElementById('rosterSeasonSelect');
    const teamSelect = document.getElementById('rosterTeamSelect');
    const summaryCap = document.getElementById('summaryCap');
    const summaryPlayers = document.getElementById('summaryPlayers');
    const summaryOpen = document.getElementById('summaryOpen');
    const summaryPractice = document.getElementById('practiceCount');
    const summaryInjured = document.getElementById('injuredCount');
    const teamNames = document.querySelectorAll('[data-team-name]');
    const teamMetas = document.querySelectorAll('[data-team-meta]');
    const teamIdentityEls = document.querySelectorAll('[data-team-identity]');
    const rosterTable = document.querySelector('.roster-table');
    const rosterTableBody = document.getElementById('rosterTableBody');
    const rosterMetadata = document.getElementById('rosterMetadata');
    const rosterCountLabel = document.getElementById('rosterCountLabel');
    const columnToggles = document.querySelectorAll('[data-column-toggle]');
    const yearTotalCells = salaryYears.map((_, index) =>
      document.getElementById(`yearTotal${index + 1}`)
    );
    const capLimitCells = salaryYears.map((_, index) =>
      document.getElementById(`capLimit${index + 1}`)
    );
    const capSpaceCells = salaryYears.map((_, index) =>
      document.getElementById(`capSpaceTotal${index + 1}`)
    );
    const dmTotalCells = salaryYears.map((_, index) =>
      document.getElementById(`dmTotal${index + 1}`)
    );
    const deadMoneyTableBody = document.getElementById('deadMoneyTableBody');
  const capDonut = document.getElementById('capDonut');
  const capLegend = null; // no longer needed in DOM
  const rosterDonut = document.getElementById('rosterDonut');
  const rosterLegend = null; // no longer needed in DOM
  const posDonut = document.getElementById('posDonut');
  const posLegend = document.getElementById('posDonut-legend');
  const subtotalActive = document.getElementById('subtotalActive');
  const subtotalPractice = document.getElementById('subtotalPractice');
  const subtotalInjured = document.getElementById('subtotalInjured');
  const subtotalDead = document.getElementById('subtotalDead');
  const countActive = document.getElementById('countActive');
    const countPractice = document.getElementById('countPractice');
    const countInjured = document.getElementById('countInjured');

    let currentSeason = defaultSeason;
    let currentTeam = defaultTeamId;
    const hiddenColumns = new Set();

    const formatCountLabel = (count) => `${count} Players`;

    const getCapPercent = (tag = 'ACTIVE', isCurrent = true) => {
      const normalized = String(tag).toUpperCase();
      const map = capInclusion?.[normalized] ?? { current: 1, future: 1 };
      return isCurrent ? map.current ?? 1 : map.future ?? 1;
    };

    const getPositionRank = (pos = '') => {
      const normalized = pos.toUpperCase();
      const index = positionOrder.indexOf(normalized);
      return index === -1 ? positionOrder.length : index;
    };

    const sortByPosition = (list = []) =>
      list.slice().sort((a, b) => {
        const diff = getPositionRank(a.position ?? '') - getPositionRank(b.position ?? '');
        if (diff !== 0) return diff;
        return (b.salary ?? 0) - (a.salary ?? 0);
      });

    const enrichPlayer = (player = {}, tag = 'active') => {
      const nflTeam = (player.nflTeam ?? player.team ?? '').toUpperCase();
      return {
        ...player,
        displayTag: tag,
        nflTeam,
        headshot: player.headshot ?? buildPlayerImageUrl(player.id),
        nflLogo: player.nflLogo ?? buildNflLogoUrl(nflTeam),
        contractYears:
          Number.parseInt(player.contractYears ?? player.contractYear ?? 0, 10) || 0,
        salary: Number(player.salary ?? 0) || 0,
        byeWeek: player.byeWeek ?? byeWeeks[nflTeam] ?? null,
      };
    };

    const annotatePositionDividers = (rows = []) => {
      const normalized = rows.map((player, index) => {
        const prevPosition =
          index > 0 ? (rows[index - 1].position ?? '').toUpperCase() : null;
        const current = (player.position ?? '').toUpperCase();
        const divider = index > 0 && current !== prevPosition;
        return { ...player, positionDivider: divider, _positionGroup: current };
      });

      return normalized.map((player, index) => {
        const next = normalized[index + 1];
        const positionDividerEnd =
          !next || (next?._positionGroup ?? '') !== (player._positionGroup ?? '');
        return { ...player, positionDividerEnd };
      });
    };

    const annotateTierDividers = (rows = []) => {
      let lastTag = null;
      return rows.map((player) => {
        const currentTag = player.displayTag ?? 'active';
        const tierDivider =
          lastTag !== null && currentTag !== lastTag && currentTag !== 'active';
        lastTag = currentTag;
        return { ...player, tierDivider };
      });
    };

    const annotateActiveStriping = (rows = []) => {
      let activeIndex = 0;
      return rows.map((player) => {
        if ((player.displayTag ?? 'active') === 'active') {
          const striped = activeIndex % 2 === 1;
          activeIndex += 1;
          return { ...player, activeStripe: striped };
        }
        return { ...player, activeStripe: false };
      });
    };

    const buildDisplayRows = (teamData = {}) => {
      const combined = [
        ...sortByPosition(teamData.players ?? []).map((player) =>
          enrichPlayer(player, 'active')
        ),
        ...sortByPosition(teamData.practiceSquad ?? []).map((player) =>
          enrichPlayer(player, 'practice')
        ),
        ...sortByPosition(teamData.injuredReserve ?? []).map((player) =>
          enrichPlayer(player, 'injured')
        ),
      ];
      return annotateActiveStriping(
        annotateTierDividers(annotatePositionDividers(combined))
      );
    };

    const getSeasonData = () =>
      seasons[currentSeason] ||
      seasons[defaultSeason] ||
      initialSeasonDataConfig ||
      {};

    const getTeamData = () => {
      const seasonData = getSeasonData();
      const teamData =
        seasonData?.teams?.[currentTeam] ||
        seasonData?.teams?.[defaultTeamId] ||
        initialTeamDataConfig || {
          players: [],
          practiceSquad: [],
          injuredReserve: [],
          totals: {
            totalSalary: 0,
            rosterCount: 0,
            openSpots: rosterLimit,
            practiceCount: 0,
            injuredCount: 0,
          },
        };
      return { seasonData, teamData };
    };

    const renderSummary = (
      capCharge = 0,
      nextYearCapCharge = 0,
      contractYearsTotal = 0,
      longestContract = 0,
      totals = {},
      deadMoney = 0,
      capLimitOverride = capLimit,
      rosterLimitOverrideLocal = rosterLimitOverride ?? rosterLimit,
      bucketCaps = { active: 0, practice: 0, injured: 0 },
      playersNextYear = 0,
      lastContractYear = ''
    ) => {
      const effectiveCap = capLimitOverride ?? capLimit ?? 0;
      const capSpace = Math.max(effectiveCap - capCharge, 0);
      const capSpaceNext = Math.max(effectiveCap - nextYearCapCharge, 0);

      if (capDonut) {
        const capSlices = [
          { label: 'Active', value: bucketCaps.active, color: '#16a34a' },
          { label: 'Practice', value: bucketCaps.practice, color: '#2563eb' },
          { label: 'Injured', value: bucketCaps.injured, color: '#dc2626' },
          { label: 'Dead Money', value: deadMoney, color: '#4b5563' },
          { label: 'Cap Space', value: capSpace, color: '#22c55e' },
        ].filter((s) => s.value > 0);
        const total = capSlices.reduce((s, c) => s + c.value, 0);
        buildDonut(capDonut, capSlices, total);
      }

      if (rosterDonut) {
        const activeCount = totals.rosterCount ?? 0;
        const practiceCount = totals.practiceCount ?? 0;
        const injuredCount = totals.injuredCount ?? 0;
        const openActive = Math.max(targetActiveCount - activeCount, 0);
        const rosterSlices = [
          { label: 'Active', value: activeCount, color: '#16a34a' },
          { label: 'Practice', value: practiceCount, color: '#2563eb' },
          { label: 'Injured', value: injuredCount, color: '#dc2626' },
          { label: 'Open Spots', value: openActive, color: '#e2e8f0' },
        ].filter((s) => s.value > 0);
        const totalSlots = rosterSlices.reduce((s, r) => s + r.value, 0);
        buildDonut(rosterDonut, rosterSlices, totalSlots);
        renderLegend(
          rosterLegend,
          rosterSlices.map((s) => ({ ...s, display: `${s.value}` }))
        );
      }

      const summaryCapNext = document.getElementById('summaryCapNext');
      if (summaryCapNext) summaryCapNext.textContent = formatCapSpaceText(capSpaceNext);
      const summaryPlayersNext = document.getElementById('summaryPlayersNext');
      if (summaryPlayersNext) summaryPlayersNext.textContent = playersNextYear;
    const summaryLastContract = document.getElementById('summaryLastContract');
    const summaryAvg2026 = document.getElementById('summaryAvg2026');
      if (summaryLastContract) summaryLastContract.textContent = lastContractYear;

      // legacy summary labels (if present)
      if (summaryCap) summaryCap.textContent = formatCapSpaceText(capSpace);
      if (summaryPlayers) summaryPlayers.textContent = totals.rosterCount ?? 0;
      if (summaryOpen) summaryOpen.textContent = totals.openSpots ?? 0;
      if (summaryPractice) summaryPractice.textContent = totals.practiceCount ?? 0;
      if (summaryInjured) summaryInjured.textContent = totals.injuredCount ?? 0;
    };

    const renderDeadMoney = (seasonData = {}, franchiseId) => {
      if (!deadMoneyTableBody) return;
      const adjustments = getSalaryAdjustments(seasonData)
        .filter((adj) => adj.franchiseId === franchiseId)
        .map((adj, idx) => {
          const baseOffset = Number(adj.yearOffset ?? adj.seasonOffset ?? 0) || 0;
          const futurePercentByYears = { 1: 0, 2: 0.15, 3: 0.25, 4: 0.35, 5: 0.45 };
          const salary = Number(adj.salary) || Number(adj.amount) || 0;
          const yearsRemaining = adj.yearsRemaining ?? 1;
          const currentPenalty = 0.5 * salary;
          const futurePenalty =
            (futurePercentByYears[yearsRemaining] ?? 0) * salary;
          return {
            ...adj,
            currentPenalty,
            futurePenalty,
            baseOffset,
            rowClass: idx % 2 ? 'eventablerow' : 'oddtablerow',
          };
        });
      if (!adjustments.length) {
        deadMoneyTableBody.innerHTML = `<tr><td colspan="${1 + salaryYears.length}" class="roster-empty">No cap hits recorded for this franchise.</td></tr>`;
        return;
      }
      const rowsHtml = adjustments
        .map((adj, idx) => {
          const cells = salaryYears
            .map((_, yearIdx) => {
              let value = '';
              if (yearIdx === adj.baseOffset) value = adj.currentPenalty;
              if (yearIdx === adj.baseOffset + 1 && adj.futurePenalty > 0)
                value = adj.futurePenalty;
              if (!value) return `<td data-column="dm-year${yearIdx + 1}" style="text-align:right"></td>`;
              return `<td data-column="dm-year${yearIdx + 1}" class="deadmoney-row__amount">${formatCurrency.format(
                value
              )}</td>`;
            })
            .join('');
          const name = adj.name || adj.description || 'Adjustment';
          const teamLabel = adj.nflTeam || 'FA';
          const nflLogo = adj.nflTeam ? buildNflLogoUrl(adj.nflTeam) : '';
          const headshot = DEFAULT_HEADSHOT_URL;
          const rowClasses = ['deadmoney-row', adj.rowClass === 'eventablerow' ? 'deadmoney-row--alt' : ''];
          return `<tr class="${rowClasses.join(' ').trim()}">
            <td data-column="player" class="deadmoney-player-cell">
              <div class="player-cell">
                <div class="player-cell__avatar player-cell__avatar--dm">
                  <img src="${headshot}" alt="${name} headshot" loading="lazy" decoding="async" onerror="this.onerror=null;this.src='${DEFAULT_HEADSHOT_URL}';" />
                </div>
                <div>
                  <strong>${name}</strong>
                  <div class="player-meta">
                    ${
                      adj.position && adj.position.toUpperCase() !== 'DEF' && nflLogo
                        ? `<img src="${nflLogo}" alt="${teamLabel} logo" class="player-meta__logo" loading="lazy" decoding="async" />`
                        : ''
                    }
                    ${adj.position ? `<span class="player-meta__pos">${adj.position}</span>` : ''}
                  </div>
                </div>
              </div>
            </td>
            ${cells}
          </tr>`;
        })
        .join('');
      deadMoneyTableBody.innerHTML = rowsHtml;
    };

    const renderTeamIdentity = (recordText = '') => {
      const meta = teams[currentTeam];
      teamIdentityEls.forEach((card) => {
        let img = card.querySelector('img');
        if (meta?.icon) {
          if (!img) {
            img = document.createElement('img');
            card.prepend(img);
          }
          img.src = meta.icon;
          img.alt = `${meta?.name ?? 'Franchise'} icon`;
        } else if (img) {
          img.remove();
        }
      });
      teamNames.forEach((el) => {
        el.textContent = meta?.name ?? 'Franchise';
      });
      const bits = [];
      if (meta?.division) bits.push(`${meta.division} Division`);
      if (recordText) bits.push(recordText);
      const metaText = bits.join(' • ') || 'Independent';
      teamMetas.forEach((el) => {
        el.textContent = metaText;
      });
    };

    const renderTableRows = (rows = []) => {
      if (!rosterTableBody) return;
      if (!rows.length) {
        rosterTableBody.innerHTML = `<tr><td colspan="${4 + salaryYears.length}" class="roster-empty">This franchise has no players recorded for this season snapshot.</td></tr>`;
        return;
      }

      rosterTableBody.innerHTML = rows
        .map((player) => {
          const useDefenseLogo =
            (player.position ?? '').toUpperCase() === 'DEF' && player.nflLogo;
          const avatarSrc = useDefenseLogo
            ? player.nflLogo
            : player.headshot ?? buildPlayerImageUrl(player.id);

          const salaryCells = salaryYears
            .map((year, index) => {
              const columnKey = `year${index + 1}`;
              const isUfa = !(player.contractYears > index);
              const isFirstYearUfa = isUfa && player.contractYears === index;
              const isFutureUfa = isUfa && player.contractYears < index;

              let value;
              let cellClass = 'salary-cell';

              if (isFirstYearUfa) {
                value = 'UFA';
                cellClass += ' salary-cell--ufa';
              } else if (isFutureUfa) {
                value = '—';
                cellClass += ' salary-cell--future-ufa';
              } else {
                value = formatCurrency.format(player.salary ?? 0);
              }

              return `<td data-label="${year}" data-column="${columnKey}" class="${cellClass}">${value}</td>`;
            })
            .join('');

          const rowClasses = [
            'roster-row',
            `roster-row--${player.displayTag ?? 'active'}`,
          ];
          if (player.positionDivider) {
            rowClasses.push('roster-row--position-divider');
          }
          if (player.positionDividerEnd) {
            rowClasses.push('roster-row--position-divider-end');
          }
          if (player.tierDivider) {
            rowClasses.push('roster-row--tier-divider');
          }
          if (player.activeStripe) {
            rowClasses.push('roster-row--active-alt');
          }

          return `<tr data-player-id="${player.id}" class="${rowClasses.join(' ')}">
            <td data-label="Player" data-column="player">
              <div class="player-cell">
                <div class="player-cell__avatar${useDefenseLogo ? ' player-cell__avatar--def' : ''}">
                  <img src="${avatarSrc}" alt="${player.name} headshot" loading="lazy" decoding="async" onerror="this.onerror=null;this.src='${DEFAULT_HEADSHOT_URL}';" />
                </div>
                <div>
                  <strong>${player.name}</strong>
                  <div class="player-meta">
                    ${
                      !useDefenseLogo && player.nflLogo
                        ? `<img src="${player.nflLogo}" alt="${player.nflTeam || 'FA'} logo" class="player-meta__logo" loading="lazy" decoding="async" />`
                        : ''
                    }
                    ${player.position ? `<span class="player-meta__pos">${player.position}</span>` : ''}
                  </div>
                </div>
              </div>
            </td>
            <td data-label="Yrs" data-column="years">${player.contractYears || 0}</td>
            ${salaryCells}
          </tr>`;
        })
        .join('');
    };

    const updateYearTotals = (rows = [], deadMoney = []) => {
      const totals = calculateCapCharges(rows);
      const capThisYearBase = Number(getTeamData().seasonData?.metadata?.capLimit ?? capLimit) || 0;
      yearTotalCells.forEach((cell, index) => {
        if (cell) cell.textContent = formatCurrency.format(totals[index] ?? 0);
        if (dmTotalCells[index]) dmTotalCells[index].textContent = formatCurrency.format(deadMoney[index] ?? 0);
        if (capLimitCells[index]) capLimitCells[index].textContent = formatCurrency.format(capThisYearBase);
        if (capSpaceCells[index])
          capSpaceCells[index].textContent = formatCurrency.format(
            capThisYearBase - ((totals[index] ?? 0) + (deadMoney[index] ?? 0))
          );
      });
      return totals;
    };

    const calculateCapCharges = (rows = []) =>
      salaryYears.map((_, index) =>
        rows.reduce((sum, player) => {
          if ((player.contractYears ?? 0) > index) {
            const isCurrent = index === 0;
            const tagRaw = (player.displayTag ?? player.status ?? 'ACTIVE').toString().toUpperCase();
            const tag = tagRaw.includes('PRACTICE')
              ? 'PRACTICE'
              : tagRaw.includes('INJURED') || tagRaw === 'IR'
                ? 'INJURED'
                : 'ACTIVE';
            const percent = getCapPercent(tag, isCurrent);
            const baseSalary = Number(player.salary ?? 0);
            const salaryForYear = baseSalary; // explicit salary for the season
            return sum + (salaryForYear * percent || 0);
          }
          return sum;
        }, 0)
      );

    const calculateBucketCaps = (rows = []) =>
      rows.reduce(
        (acc, player) => {
          const tag = (player.displayTag ?? 'active').toUpperCase();
          const isCurrent = true;
          const percent = getCapPercent(tag, isCurrent);
          const salary = Number(player.salary ?? 0) || 0;
          if (tag === 'PRACTICE') {
            acc.practice += salary * percent;
            acc.counts.practice += 1;
          } else if (tag === 'INJURED') {
            acc.injured += salary * percent;
            acc.counts.injured += 1;
          } else {
            acc.active += salary * percent;
            acc.counts.active += 1;
          }
          return acc;
        },
        { active: 0, practice: 0, injured: 0, counts: { active: 0, practice: 0, injured: 0 } }
      );

    const calculatePositionCaps = (rows = []) =>
      rows.reduce((totals, player) => {
        if ((player.contractYears ?? 0) <= 0) return totals;
        const tagRaw = (player.displayTag ?? player.status ?? 'ACTIVE').toString().toUpperCase();
        const tag = tagRaw.includes('PRACTICE')
          ? 'PRACTICE'
          : tagRaw.includes('INJURED') || tagRaw === 'IR'
            ? 'INJURED'
            : 'ACTIVE';
        const percent = getCapPercent(tag, true);
        const pos = (player.position ?? 'UNK').toUpperCase();
        const salary = (Number(player.salary ?? 0) || 0) * percent;
        totals[pos] = (totals[pos] ?? 0) + salary;
        return totals;
      }, {});

    const getSalaryAdjustments = (seasonData = {}) => {
      if (Array.isArray(seasonData.salaryAdjustments)) return seasonData.salaryAdjustments;
      if (adjustmentsBySeason[currentSeason]) return adjustmentsBySeason[currentSeason];
      if (adjustmentsBySeason[defaultSeason]) return adjustmentsBySeason[defaultSeason];
      if (Array.isArray(initialSeasonDataConfig?.salaryAdjustments))
        return initialSeasonDataConfig.salaryAdjustments;
      return [];
    };

    const setCapSubtotals = (caps, deadMoneyCurrent, capSpaceCurrent) => {
      if (subtotalActive) subtotalActive.textContent = formatCurrency.format(caps.active);
      if (subtotalPractice) subtotalPractice.textContent = formatCurrency.format(caps.practice);
      if (subtotalInjured) subtotalInjured.textContent = formatCurrency.format(caps.injured);
      if (countActive) countActive.textContent = `(${caps.counts?.active ?? 0})`;
      if (countPractice) countPractice.textContent = `(${caps.counts?.practice ?? 0})`;
      if (countInjured) countInjured.textContent = `(${caps.counts?.injured ?? 0})`;
      if (subtotalDead) subtotalDead.textContent = formatCurrency.format(deadMoneyCurrent);
      const subtotalCapSpace = document.getElementById('subtotalCapSpace');
      if (subtotalCapSpace)
        subtotalCapSpace.textContent = formatCurrency.format(capSpaceCurrent ?? 0);
    };

    const aggregateDeadMoney = (seasonData = {}, franchiseId) => {
      const adjustments = getSalaryAdjustments(seasonData);
      return salaryYears.map((_, idx) =>
        adjustments.reduce((sum, adj) => {
          if (adj.franchiseId !== franchiseId) return sum;
          const baseOffset = Number(adj.yearOffset ?? adj.seasonOffset ?? 0);
      const salary = Number(adj.salary) || Number(adj.amount) || 0;
      const yearsRemaining = adj.yearsRemaining;
      const hasYearsRemaining = Number.isFinite(yearsRemaining);
      const futurePercentByYears = { 1: 0, 2: 0.15, 3: 0.25, 4: 0.35, 5: 0.45 };
      const currentPenalty = hasYearsRemaining ? 0.5 * salary : salary; // carryover hits 100% current year
      const futurePenalty =
        hasYearsRemaining ? (futurePercentByYears[yearsRemaining] ?? 0) * salary : 0;
          let total = sum;
          if (idx === baseOffset) total += currentPenalty;
          if (idx === baseOffset + 1 && futurePenalty > 0) total += futurePenalty;
          return total;
        }, 0)
      );
    };

    const calculateContractYearsMeta = (rows = []) => {
      const contractYearsTotal = rows.reduce(
        (sum, player) => sum + Math.max(Number(player.contractYears ?? 0) || 0, 0),
        0
      );
      const longestContract = rows.reduce(
        (max, player) => Math.max(max, Number(player.contractYears ?? 0) || 0),
        0
      );
      return { contractYearsTotal, longestContract };
    };

    const buildDonut = (el, slices = [], total = 0) => {
      if (!el) return;
      if (!total || total <= 0 || !slices.length) {
        el.style.background = 'conic-gradient(#e2e8f0 0deg, #e2e8f0 360deg)';
        return;
      }
      let start = 0;
      const parts = slices
        .filter((s) => s.value > 0)
        .map((s) => {
          const angle = (s.value / total) * 360;
          const end = start + angle;
          const gradient = `${s.color} ${start}deg ${end}deg`;
          start = end;
          return gradient;
        });
      if (!parts.length) {
        el.style.background = 'conic-gradient(#e2e8f0 0deg, #e2e8f0 360deg)';
        return;
      }
      el.style.background = `conic-gradient(${parts.join(',')})`;
    };

    const renderLegend = (el, slices = []) => {
      // legend removed (subtotals act as legend)
    };

    const renderLegendList = (el, slices = []) => {
      if (!el) return;
      if (!slices.length) {
        el.innerHTML = '';
        return;
      }
      el.innerHTML = slices
        .map(
          (slice) => `<div class="chart-legend__item">
            <span class="chart-legend__label">
              <span class="legend-dot" style="background:${slice.color}"></span>
              ${slice.label}
            </span>
            <span class="chart-legend__value">${formatCurrency.format(slice.value)}</span>
          </div>`
        )
        .join('');
    };

    const applyHiddenColumns = () => {
      if (!rosterTable) return;
      rosterTable.dataset.hiddenColumns = Array.from(hiddenColumns).join(' ');
    };

    const updateView = () => {
      const { seasonData, teamData } = getTeamData();
      const rows = buildDisplayRows(teamData);
      const deadMoney = aggregateDeadMoney(seasonData, currentTeam);
      const yearTotals = updateYearTotals(rows, deadMoney);
      const capCharges = calculateCapCharges(rows);
      const capChargesWithDead = capCharges.map((val, idx) => val + (deadMoney[idx] ?? 0));
      const capCharge = capChargesWithDead?.[0] ?? 0;
      const nextYearCapCharge = capChargesWithDead?.[1] ?? 0;
      const { contractYearsTotal, longestContract } = calculateContractYearsMeta(rows);
      const capLimitForSeason = Number(
        seasonData?.metadata?.capLimit ?? capLimit ?? 0
      );
      const rosterLimitForSeason = Number(
        seasonData?.metadata?.rosterLimit ?? rosterLimitOverride ?? rosterLimit ?? 0
      );
      const deadMoneyCurrent = deadMoney[0] ?? 0;
      const playersNextYear = rows.filter((p) => (p.contractYears ?? 0) > 1).length;
      const lastContractYear =
        (seasonData?.metadata?.season
          ? Number(seasonData.metadata.season)
          : Number(defaultSeason)) +
        Math.max(longestContract - 1, 0);
      renderSummary(
        capCharge,
        nextYearCapCharge,
        contractYearsTotal,
        longestContract,
        teamData.totals ?? {},
        deadMoneyCurrent,
        capLimitForSeason,
        rosterLimitForSeason,
        calculateBucketCaps(rows),
        playersNextYear,
        lastContractYear
      );
      const bucketCapsCurrent = calculateBucketCaps(rows);
      setCapSubtotals(bucketCapsCurrent, deadMoneyCurrent, capLimitForSeason - capCharge);
      renderTeamIdentity(teamData.record ?? '');
      renderTableRows(rows);
      renderDeadMoney(seasonData, currentTeam);

      const activeCount = teamData.totals?.rosterCount ?? rows.filter((p) => (p.displayTag ?? 'active') === 'active').length;
      const remainingSlots2026 = Math.max(targetActiveCount - playersNextYear, 1);
      const playersToCut2026 = Math.max(playersNextYear - targetActiveCount, 0);
      const playersToCutToSign2026 = Math.max(playersNextYear - targetActiveCount + 1, 0);
      const needsToCutToSign2026 = playersNextYear >= targetActiveCount;
      const deadMoney2026 = deadMoney[1] ?? 0;
      const capSpace2026 =
        capLimitForSeason -
        (capChargesWithDead?.[1] ?? 0) -
        reserveForRookies;
      const avgPerPlayer2026 = Math.max(capSpace2026, 0) / remainingSlots2026;
      if (summaryAvg2026) summaryAvg2026.textContent = `${formatCurrency.format(avgPerPlayer2026)} × ${remainingSlots2026}`;

      const summaryDeadMoney2026 = document.getElementById('summaryDeadMoney2026');
      if (summaryDeadMoney2026) summaryDeadMoney2026.textContent = formatCurrency.format(deadMoney2026);

      const needsToCutRosterHint = document.getElementById('needsToCutRoster2026');
      if (needsToCutRosterHint) {
        if (playersToCut2026 > 0) {
          const playerWord = playersToCut2026 === 1 ? 'player' : 'players';
          needsToCutRosterHint.textContent = `Must cut ${playersToCut2026} ${playerWord} by cutdown`;
          needsToCutRosterHint.style.display = 'block';
        } else {
          needsToCutRosterHint.style.display = 'none';
        }
      }

      const positionCaps = calculatePositionCaps(rows);
      const posEntries = Object.entries(positionCaps).sort((a, b) => b[1] - a[1]);
      const posPalette = ['#a855f7', '#ec4899', '#facc15', '#c084fc'];
      const posSlices = posEntries.map(([label, value], idx) => {
        const upper = label.toUpperCase();
        const color = positionColors[upper] ?? posPalette[idx % posPalette.length];
        return { label, value, color };
      });
      const posTotal = posSlices.reduce((sum, s) => sum + s.value, 0);
      buildDonut(posDonut, posSlices, posTotal);
      renderLegendList(posLegend, posSlices);

      if (rosterMetadata) {
        rosterMetadata.textContent = `Season ${
          seasonData?.metadata?.season ?? currentSeason
        }`;
      }
      if (rosterCountLabel) {
        rosterCountLabel.textContent = formatCountLabel(rows.length ?? 0);
      }
    };

    columnToggles.forEach((toggle) => {
      toggle.addEventListener('change', (event) => {
        const key = toggle.getAttribute('data-column-toggle');
        if (!key) return;
        if (event.target.checked) {
          hiddenColumns.delete(key);
        } else {
          hiddenColumns.add(key);
        }
        applyHiddenColumns();
      });
    });

    seasonSelect?.addEventListener('change', (event) => {
      currentSeason = event.target.value;
      updateView();
    });

    teamSelect?.addEventListener('change', (event) => {
      currentTeam = event.target.value;
      updateView();
    });

    // Team icon navigation
    const teamIconBtns = document.querySelectorAll('.team-icon-btn');
    teamIconBtns.forEach((btn) => {
      btn.addEventListener('click', () => {
        const teamId = btn.getAttribute('data-team-id');
        if (!teamId) return;

        // Update active state
        teamIconBtns.forEach((b) => b.setAttribute('data-active', 'false'));
        btn.setAttribute('data-active', 'true');

        // Update hidden input and current team
        if (teamSelect) teamSelect.value = teamId;
        currentTeam = teamId;
        updateView();
      });
    });

    applyHiddenColumns();
    updateView();
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initRosterPage);
  } else {
    initRosterPage();
  }
</script>
